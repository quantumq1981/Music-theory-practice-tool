<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scale & Mode Practice Tool</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            sans: ['Inter', 'sans-serif'],
          },
          colors: {
            'root-note': '#10b981', // Emerald 500 (Green)
            'scale-note': '#000000', // Black
            'fretboard-wood': '#6e4e3e',
          }
        }
      }
    }
  </script>
  <style>
    :root {
      --root-note: #10b981;
      --scale-note: #000000;
      --fret-mark: #374151;
    }

    .fretboard-container {
      overflow-x: auto;
      max-width: 100%;
    }
    .string { stroke: #e5e5e5; stroke-width: 2; }
    .fret { stroke: #888; stroke-width: 2; }
    .nut { stroke: var(--fret-mark); stroke-width: 5; }
    .note-circle { fill: var(--scale-note); transition: all 0.1s; cursor: pointer; }
    .root-circle { fill: var(--root-note); transition: all 0.1s; cursor: pointer; }
    .note-label { fill: white; pointer-events: none; }
    .fret-dot { fill: var(--fret-mark); }

    th, td { border: 1px solid #e5e7eb; padding: 6px 8px; }

    /* Custom Switch Styling for Scale Degree Toggle */
    .toggle-checkbox:checked + .toggle-label {
      background-color: #4f46e5;
    }
    .toggle-checkbox:checked + .toggle-label::after {
      transform: translateX(100%);
    }
    .toggle-label::after {
        content: '';
        position: absolute;
        left: 4px;
        top: 4px;
        width: 12px;
        height: 24px; /* Adjusted height */
        background-color: white;
        border-radius: 9999px;
        transition: transform 0.2s;
    }

    /* New styles for Gemini features */
    .loader {
      border: 4px solid #f3f3f3; /* Light grey */
      border-top: 4px solid #4f46e5; /* Indigo */
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .gemini-output pre {
      background-color: #1f2937; /* Gray 800 */
      color: #f9fafb; /* Gray 50 */
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      white-space: pre-wrap; /* Wraps text, preserves newlines */
      word-wrap: break-word;
      font-family: 'Courier New', Courier, monospace;
    }

    /* Voicing Highlight (from click) */
    .voicing-highlight {
        fill: #ef4444; /* Red 500 */
        opacity: 0.85;
        stroke: white;
        stroke-width: 2;
        pointer-events: none;
        transition: all 0.05s;
    }
  </style>
</head>
<body class="bg-gray-100 font-sans text-gray-800 p-4 sm:p-6">

  <div class="max-w-4xl mx-auto space-y-8">

    <header class="text-center py-6 bg-white shadow-xl rounded-xl">
      <h1 class="text-3xl font-extrabold text-indigo-700">Fretboard Scale & Mode Visualizer</h1>
      <p class="text-sm text-gray-500 mt-1">Enharmonic support, audio playback, and scale degrees enabled!</p>
    </header>

    <div class="bg-white p-6 shadow-xl rounded-xl space-y-4">
      <h2 class="text-xl font-bold border-b pb-2 text-gray-700">1. Select and Visualize Scale</h2>

      <div class="grid grid-cols-2 md:grid-cols-5 gap-4 items-end">
        
        <div>
          <label for="typeSelect" class="block text-sm font-medium text-gray-600 mb-1">Scale Type:</label>
          <select id="typeSelect" aria-label="Scale Type" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
            <option value="mode">Diatonic Modes (Major Derived)</option>
            <option value="harmonic">Harmonic Minor Modes</option>
            <option value="melodic">Melodic Minor Modes</option>
            <option value="pentatonic">Pentatonic</option>
            <option value="diminished">Diminished/Symmetrical</option>
            <option value="extended">Extended / Exotic</option>
          </select>
        </div>
        
        <div>
          <label for="choiceSelect" class="block text-sm font-medium text-gray-600 mb-1">Scale/Mode Choice:</label>
          <select id="choiceSelect" aria-label="Scale Choice" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
            </select>
        </div>
        
        <div>
          <label for="rootSelect" class="block text-sm font-medium text-gray-600 mb-1">Root Note (Tonic):</label>
          <select id="rootSelect" aria-label="Root Note" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
            </select>
        </div>
        
        <div>
          <label for="notationSelect" class="block text-sm font-medium text-gray-600 mb-1">Note Notation:</label>
          <select id="notationSelect" aria-label="Note Notation Preference" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
            <option value="sharp" selected>Sharps (C#)</option>
            <option value="flat">Flats (Db)</option>
          </select>
        </div>

        <div class="flex flex-col items-center justify-center">
            <span class="block text-sm font-medium text-gray-600 mb-1">Label Mode:</span>
            <div class="flex items-center space-x-2 h-full">
                <input type="checkbox" id="degreeToggle" class="hidden toggle-checkbox">
                <label for="degreeToggle" class="relative block w-10 h-6 cursor-pointer rounded-full bg-gray-300 transition-colors duration-200 ease-in-out toggle-label">
                    <span class="absolute left-1 top-1 w-4 h-4 bg-white rounded-full shadow transition-transform duration-200 ease-in-out transform"></span>
                </label>
                <span class="text-xs font-medium text-gray-700 select-none">Degrees (R, b3)</span>
            </div>
        </div>

      </div>

      <div class="flex gap-4 pt-2">
        <button id="showScaleBtn" class="flex-1 py-2 px-4 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition duration-150 ease-in-out">
          Show Scale & Chords
        </button>
        <button id="playScaleBtn" class="w-2/5 md:w-1/4 py-2 px-4 bg-emerald-500 text-white font-semibold rounded-lg shadow-md hover:bg-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-400 focus:ring-offset-2 transition duration-150 ease-in-out">
          ▶️ Play Scale
        </button>
      </div>


      <div id="scaleNotes" aria-live="polite" class="mt-4 p-3 bg-indigo-50 text-indigo-800 rounded-lg font-mono text-center text-sm sm:text-base">
        Select a scale type, choice, and root note above.
      </div>
      
      <div id="scaleAnalysis" class="mt-4 p-3 bg-gray-50 border border-gray-200 rounded-lg text-sm space-y-2">
        </div>


      <div id="fretboard" class="fretboard-container bg-fretboard-wood rounded-lg shadow-inner border-2 border-gray-900">
        </div>
    </div>

    <div class="bg-white p-6 shadow-xl rounded-xl">
      <h2 class="text-xl font-bold border-b pb-2 text-gray-700">2. Diatonic Chords and Voicings</h2>
      <p class="text-sm text-gray-500 mt-2">Click on any voicing (e.g., `x 3 2 0 0 0`) to see the finger position highlighted on the fretboard.</p>
      
      <button id="clearHighlightsBtn" class="mt-3 py-1 px-3 bg-gray-200 text-gray-700 text-xs font-semibold rounded-lg hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 transition duration-150 ease-in-out">
          Clear Voicing Highlights
      </button>

      <div id="chordOutput" class="mt-4">
        </div>
      <p id="chordError" class="mt-4 text-red-600 font-semibold hidden">This scale type does not generate standard diatonic 7th chords (e.g., pentatonic, hexatonic scales).</p>
    </div>

    <div class="bg-white p-6 shadow-xl rounded-xl">
      <h2 class="text-xl font-bold border-b pb-2 text-indigo-700">3. ✨ Gemini Practice Tools</h2>
      <p class="text-sm text-gray-500 mt-2">Use AI to get creative practice ideas based on your selected scale.</p>
      
      <div class="flex flex-col sm:flex-row gap-4 pt-4">
        <button id="getLickBtn" class="flex-1 py-2 px-4 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 transition duration-150 ease-in-out">
          ✨ Suggest a Practice Lick
        </button>
        <button id="getProgressionBtn" class="flex-1 py-2 px-4 bg-teal-600 text-white font-semibold rounded-lg shadow-md hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-offset-2 transition duration-150 ease-in-out">
          ✨ Suggest Chord Progression
        </button>
      </div>

      <div id="geminiOutputWrapper" class="mt-4 p-4 bg-gray-50 border border-gray-200 rounded-lg min-h-[100px] hidden">
        <div id="geminiOutput">
          </div>
      </div>
    </div>

  </div>

  <script>
    // --- Musical Data Structures ---
    
    // Enharmonic Note Map (Internal Canonical 0-11)
    const noteMap = [
      { sharp: "C", flat: "C", index: 0 },
      { sharp: "C#", flat: "Db", index: 1 },
      { sharp: "D", flat: "D", index: 2 },
      { sharp: "D#", flat: "Eb", index: 3 },
      { sharp: "E", flat: "E", index: 4 },
      { sharp: "F", flat: "F", index: 5 },
      { sharp: "F#", flat: "Gb", index: 6 },
      { sharp: "G", flat: "G", index: 7 },
      { sharp: "G#", flat: "Ab", index: 8 },
      { sharp: "A", flat: "A", index: 9 },
      { sharp: "A#", flat: "Bb", index: 10 },
      { sharp: "B", flat: "B", index: 11 },
    ];
    
    const svgNS = "http://www.w3.org/2000/svg";

    // --- Helper Functions for Notes ---
    function getNoteName(index, notation) {
      return noteMap[index % 12][notation];
    }

    function getNoteIndex(noteStr) {
      const found = noteMap.find(n => n.sharp === noteStr || n.flat === noteStr);
      return found ? found.index : -1;
    }

    // List of all possible root notes for the dropdown
    const allRootNotes = noteMap.map(n => n.sharp);

    // --- Audio Playback Functions (Web Audio API) ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;

    function initAudioContext() {
      if (!audioCtx) {
        audioCtx = new AudioContext();
      }
      // Attempt to resume context if it's suspended (common browser requirement)
      if (audioCtx.state === 'suspended') {
        audioCtx.resume().catch(e => console.error("AudioContext resume failed:", e));
      }
      return audioCtx;
    }
    
    function getFrequency(noteName) {
      // Mapping from C4 (index 0) to standard frequency
      // Using C3 as base for a lower, more pleasant guitar-like range
      const freqMap = {
        "C": 130.81, "C#": 138.59, "Db": 138.59,
        "D": 146.83, "D#": 155.56, "Eb": 155.56,
        "E": 164.81, "F": 174.61, "F#": 185.00, "Gb": 185.00,
        "G": 196.00, "G#": 207.65, "Ab": 207.65,
        "A": 220.00, "A#": 233.08, "Bb": 233.08,
        "B": 246.94
      };
      // Use C3 range, and C4 for notes played on high E/B strings (simple check)
      const baseFreq = freqMap[noteName] || 0;
      return baseFreq;
    }

    function playNote(noteName, duration = 0.3, delay = 0, octave = 0) {
      try {
        const context = initAudioContext();

        let freq = getFrequency(noteName);
        if (freq === 0) return;

        // Apply octave shift (0 = C3 range, 1 = C4 range)
        freq = freq * Math.pow(2, octave);

        const osc = context.createOscillator();
        const gain = context.createGain();

        osc.frequency.setValueAtTime(freq, context.currentTime + delay);
        osc.type = "sine"; // "triangle" or "sawtooth" can sound more "guitary"
        
        // Simple ADSR envelope
        gain.gain.setValueAtTime(0, context.currentTime + delay);
        gain.gain.linearRampToValueAtTime(0.3, context.currentTime + delay + 0.05); // Attack
        gain.gain.linearRampToValueAtTime(0.15, context.currentTime + delay + 0.15); // Decay
        gain.gain.linearRampToValueAtTime(0, context.currentTime + delay + duration); // Release

        osc.connect(gain).connect(context.destination);
        osc.start(context.currentTime + delay);
        osc.stop(context.currentTime + delay + duration);
      } catch (error) {
        console.error("Error playing note:", error);
      }
    }
    
    function playScale(scaleNotes) {
        let delay = 0;
        scaleNotes.forEach(note => {
            playNote(note, 0.25, delay, 1); // Play scale in C4 octave
            delay += 0.3;
        });
        // Play root note again at the end
        playNote(scaleNotes[0], 0.3, delay, 2); // C5 octave
    }

    // ⭐ SUGGESTION: New function to play chords
    function playChord(noteNames) {
        initAudioContext();
        noteNames.forEach((note, index) => {
            // Simple octave logic: higher strings get higher octave
            const octave = (index > 3) ? 1 : 0; // High B/E strings = octave 1
            playNote(note, 0.8, 0, octave); // Play all at once (delay=0) for 0.8s
        });
    }

    // --- Scale Definitions (unchanged) ---
    const modes = {
      Ionian: ["1","2","3","4","5","6","7"],
      Dorian: ["1","2","b3","4","5","6","b7"],
      Phrygian: ["1","b2","b3","4","5","b6","b7"],
      Mixolydian: ["1","2","3","4","5","6","b7"],
      Lydian: ["1","2","3","#4","5","6","7"],
      Aeolian: ["1","2","b3","4","5","b6","b7"],
      Locrian: ["1","b2","b3","4","b5","b6","b7"]
    };

    const harmonicMinorModes = {
        "Harmonic Minor": ["1", "2", "b3", "4", "5", "b6", "7"],
        "Phrygian Dominant": ["1", "b2", "3", "4", "5", "b6", "b7"],
        "Locrian ♮6": ["1", "b2", "b3", "4", "b5", "6", "b7"],
        "Ionian ♯5": ["1", "2", "3", "4", "#5", "6", "7"],
    };

    const melodicMinorModes = {
        "Melodic Minor (Asc)": ["1", "2", "b3", "4", "5", "6", "7"],
        "Altered (Super Locrian)": ["1", "b2", "b3", "b4", "b5", "b6", "b7"],
        "Lydian Dominant": ["1", "2", "3", "#4", "5", "6", "b7"],
        "Mixolydian ♭6": ["1", "2", "3", "4", "5", "b6", "b7"],
    };

    const pentatonics = {
      "Major Pentatonic": ["1","2","3","5","6"],
      "Minor Pentatonic": ["1","b3","4","5","b7"],
      "Blues (Hexatonic)": ["1", "b3", "4", "#4", "5", "b7"] 
    };

    const diminishedScales = {
      "Whole-Half Diminished": ["1","2","b3","4","b5","b6","6","7"],
      "Half-Whole Diminished": ["1","b2","b3","3","b5","5","6","b7"],
    };

    // Extended Scales
    const extendedScales = {
      "Bebop Major (Octatonic)": ["1", "2", "3", "4", "5", "6", "b7", "7"],
      "Harmonic Major": ["1", "2", "3", "4", "5", "b6", "7"],
      "Double Harmonic (Byzantine)": ["1", "b2", "3", "4", "5", "b6", "7"],
      "Whole Tone (Hexatonic)": ["1", "2", "3", "#4", "#5", "b7"]
    };

    const scaleTypes = {
      mode: modes,
      harmonic: harmonicMinorModes,
      melodic: melodicMinorModes,
      pentatonic: pentatonics,
      diminished: diminishedScales,
      extended: extendedScales
    };
    
    /* ---------- VOICING LIBRARY (FIXED FORMAT) ---------- */
    /* Format: 6 space-separated values for strings E A D G B e (low to high). */
    const voicingLibrary = {
      "Maj7": ["x 3 2 0 0 0", "x 0 2 1 2 0", "8 7 9 9 8 7"],
      "m7": ["x 0 2 0 1 0", "5 7 5 5 5 5", "8 10 8 9 8 8"],
      "7": ["3 2 0 0 0 1", "x 0 2 0 2 3", "8 10 8 9 10 8"],
      "m7b5": ["x 2 3 2 3 x", "3 5 3 4 3 3", "7 8 7 8 7 x"],
      "dim7": ["x 3 4 5 3 x", "x x 2 3 1 3", "6 7 8 6 7 8"],
      "dim": ["x 3 4 2 4 x", "x x 3 4 5 4"],
      "aug": ["x 3 2 1 0 x", "3 3 2 1 1 0"],
      "sus4": ["x 3 3 0 1 1", "3 3 0 0 1 1"],
      "Maj7#5": ["x 0 2 1 4 x", "7 6 6 8 8 7"],
      "7b9": ["x 0 2 0 2 3", "x 2 1 2 3 x", "7 6 7 7 6 7"],
      "7#9": ["x 7 6 7 7 x", "7 6 7 8 7 7"],
      "7b13": ["x 0 2 0 2 3", "6 5 6 6 5 6"],
      "sus2": ["x 0 2 2 0 0", "7 7 9 9 7 7"],
      "alt": ["x 7 6 7 6 x", "7 6 7 6 7 6"],
      "add9": ["x 0 2 4 0 0", "7 9 9 9 7 7"],
      "Maj7#11": ["x 0 2 1 2 x", "7 6 5 8 7 7"]
    };

    /* ---------- SCALE CHORD SUGGESTIONS (unchanged) ---------- */
    const scaleChordSuggestions = {
      // Diminished / Symmetrical
      "Whole-Half Diminished": [
        { chord: "dim7", label: "Fully diminished 7 (symmetrical stack of minor 3rds). Great as a tonic/mediant color.", voicings: voicingLibrary["dim7"] || [] },
        { chord: "m7b5", label: "Half-diminished (use on iiø of minor-ish contexts).", voicings: voicingLibrary["m7b5"] || [] },
        { chord: "7b9", label: "Dominant with ♭9 tensions — color over dominant-function passages.", voicings: voicingLibrary["7b9"] || [] },
        { chord: "alt", label: "Altered dominant clusters — use for resolving tensions.", voicings: voicingLibrary["alt"] || [] }
      ],
      "Half-Whole Diminished": [
        { chord: "dim7", label: "Diminished clusters; symmetric diminished arpeggios work well.", voicings: voicingLibrary["dim7"] || [] },
        { chord: "7#9", label: "Dominant with #9 color — commonly used over diminished-derived dominants.", voicings: voicingLibrary["7#9"] || [] },
        { chord: "7b13", label: "Dominant with lowered 13 for dark color.", voicings: voicingLibrary["7b13"] || [] }
      ],
      // Whole Tone as a symmetrical / exotic
      "Whole Tone (Hexatonic)": [
        { chord: "7#5", label: "Dominant with augmented 5th (whole-tone pool), invokes dream/floaty dominant.", voicings: voicingLibrary["Maj7#5"] || [] },
        { chord: "7#11", label: "Dominant with #11 (augmented 4) — altered Lydian dominant colors.", voicings: voicingLibrary["Maj7#11"] || [] },
        { chord: "aug", label: "Augmented triads/arpeggios sit naturally.", voicings: voicingLibrary["aug"] || [] }
      ],
      // Bebop / extended / exotic
      "Bebop Major (Octatonic)": [
        { chord: "Maj7", label: "Major tonic with chromatic passing (bebop flavor).", voicings: voicingLibrary["Maj7"] || [] },
        { chord: "7", label: "Dominant sounds on V — use 9/13 tension voicings.", voicings: voicingLibrary["7"] || [] }
      ],
      "Harmonic Major": [
        { chord: "Maj7", label: "Major tonic with lowered 6th color (Maj7(b6) implication).", voicings: voicingLibrary["Maj7"] || [] },
        { chord: "7b9", label: "Dominant with exotic b9 colors (fit for V that uses harmonic major).", voicings: voicingLibrary["7b9"] || [] }
      ],
      "Double Harmonic (Byzantine)": [
        { chord: "Maj7#11", label: "Major tonic with #11 / augmented flavor & exotic step (b2 color).", voicings: voicingLibrary["Maj7#11"] || [] },
        { chord: "7b9", label: "Dominant with strong b9 flavor (phrygian-ish dominants).", voicings: voicingLibrary["7b9"] || [] }
      ],
      "Blues (Hexatonic)": [
        { chord: "m7", label: "Minor pentatonic/blues over a minor tonic.", voicings: voicingLibrary["m7"] || [] },
        { chord: "7", label: "Dominant blues color for V/turnarounds.", voicings: voicingLibrary["7"] || [] }
      ],
      "Major Pentatonic": [
        { chord: "Maj7", label: "Major tonic (I) - great for simple folk or rock.", voicings: voicingLibrary["Maj7"] || [] },
        { chord: "7", label: "Dominant (V) - common rock/blues color.", voicings: voicingLibrary["7"] || [] }
      ],
      "Minor Pentatonic": [
        { chord: "m7", label: "Minor tonic (i) - classic rock/blues minor sound.", voicings: voicingLibrary["m7"] || [] },
        { chord: "7", label: "Dominant (V) - common rock/blues color.", voicings: voicingLibrary["7"] || [] }
      ]
    };


    // --- Architectural Improvement: SVG Abstraction ---
    function createSVGElement(tag, attrs = {}) {
      const el = document.createElementNS(svgNS, tag);
      for (const [key, val] of Object.entries(attrs)) {
        el.setAttribute(key, val);
      }
      return el;
    }

    // --- Architectural Improvement: Robust Interval Parsing ---
    function intervalToSemitone(intervalStr) {
      const baseIntervals = { '1': 0, '2': 2, '3': 4, '4': 5, '5': 7, '6': 9, '7': 11, '8': 12 }; // Added '8' for potential use
      
      const numMatch = intervalStr.match(/[1-8]/);
      if (!numMatch) return 0;
      const num = numMatch[0];
      const acc = intervalStr.replace(num, '');

      let semitones = baseIntervals[num] || 0;

      if (acc.includes('b')) semitones -= acc.match(/b/g).length;
      if (acc.includes('#')) semitones += acc.match(/#/g).length;
      
      return (semitones % 12 + 12) % 12;
    }

    // New: Calculate Whole/Half Step Pattern
    function calculateWHTrail(intervals) {
        if (!intervals || intervals.length === 0) return 'N/A';
        
        // 1. Get semitone offset for each interval
        const semitones = intervals.map(intervalToSemitone); 
        
        // 2. Calculate the distance between successive notes (including the octave wrap)
        const steps = [];
        let prevSemitone = 0;
        
        for (let i = 0; i < semitones.length; i++) {
            const currentSemitone = semitones[i];
            
            // Calculate step from previous note to current note
            let diff = currentSemitone - prevSemitone;
            if (diff < 0) diff += 12; // Should not happen with sorted intervals, but safe check

            if (i > 0) { // Skip calculation for the root (interval 1)
                steps.push(diff);
            }
            
            prevSemitone = currentSemitone;
        }

        // Calculate the step back to the octave (12 semitones)
        const lastStep = 12 - prevSemitone;
        if (lastStep > 0) { // Only push if it's a valid step back (i.e., not a 12-note scale)
             steps.push(lastStep);
        }
        
        // 3. Map semitone differences to W/H
        return steps.map(step => {
            if (step === 1) return 'H'; // Half Step
            if (step === 2) return 'W'; // Whole Step
            if (step === 3) return 'W+H'; // Augmented second
            return 'X'; 
        }).join(' – ');
    }

    // New: Get Descriptive Derivation Text
    function getScaleDerivation(type, choice, root, intervals) {
        if (type === 'mode') {
            const degrees = {
                Ionian: "1st", Dorian: "2nd", Phrygian: "3rd", Lydian: "4th", 
                Mixolydian: "5th", Aeolian: "6th", Locrian: "7th"
            };
            const degree = degrees[choice] || "Unknown";
            
            // Find the Major key this mode starts on (e.g., C Mixolydian is the 5th degree of F Major)
            // Interval for the 5th degree is 7 semitones (1 + 7 = 8, 8%12 = 8, 8 is Ab/G#)
            // But we need to calculate the root of the parent scale.
            const degreeOffset = {
                Ionian: 0, Dorian: 2, Phrygian: 4, Lydian: 5, 
                Mixolydian: 7, Aeolian: 9, Locrian: 11
            };
            const modeInterval = degreeOffset[choice];
            const majorRootIndex = (getNoteIndex(root) - modeInterval + 12) % 12; 
            const majorRootName = getNoteName(majorRootIndex, 'sharp'); 
            
            return `This mode is derived from the **${majorRootName} Major** scale (Ionian), starting on its **${degree}** degree.`;
        }
        if (choice.includes("Pentatonic") || choice.includes("Blues")) {
            return `A scale focused on consonance. The Major Pentatonic is a Major scale (Ionian) with the 4th and 7th degrees removed.`;
        }
        if (choice === "Harmonic Minor") {
            const naturalMinorRoot = root;
            const naturalMinor7th = getNoteName((getNoteIndex(root) + 10) % 12, 'flat'); // b7 of natural minor
            const raised7th = getNoteName((getNoteIndex(root) + 11) % 12, 'sharp'); // 7 of harmonic minor
            return `Built from the **${naturalMinorRoot} Natural Minor** scale by raising the **7th degree** (${naturalMinor7th}) by a half-step to **${raised7th}**.`;
        }
        if (choice === "Melodic Minor (Asc)") {
             return `The Melodic Minor scale is built from Natural Minor by raising both the **6th and 7th degrees** by a half-step.`;
        }
        return `The **${choice}** is a unique scale characterized by its specific interval formula: **${intervals.join("-")}**.`;
    }

    // Updated buildScale to use enharmonic map
    function buildScale(root, intervals) {
      const notation = document.getElementById("notationSelect").value;
      const rootIdx = getNoteIndex(root);
      if (rootIdx === -1) return { scaleNotes: [], intervals: [] };
      
      const scaleNotes = intervals.map(iv => {
        const offs = intervalToSemitone(iv);
        return getNoteName((rootIdx + offs) % 12, notation);
      });
      return { scaleNotes, intervals };
    }

    // --- DOM Elements and Handlers (unchanged) ---
    const typeSelect = document.getElementById("typeSelect");
    const choiceSelect = document.getElementById("choiceSelect");
    const rootSelect = document.getElementById("rootSelect");
    const notationSelect = document.getElementById("notationSelect");
    const degreeToggle = document.getElementById("degreeToggle");
    const showScaleBtn = document.getElementById("showScaleBtn");
    const playScaleBtn = document.getElementById("playScaleBtn");
    const chordOutputDiv = document.getElementById("chordOutput");
    const chordErrorP = document.getElementById("chordError");
    const scaleAnalysisDiv = document.getElementById("scaleAnalysis"); 
    const clearHighlightsBtn = document.getElementById("clearHighlightsBtn"); // ⭐ New Button
    
    // --- New Gemini DOM Elements ---
    const getLickBtn = document.getElementById("getLickBtn");
    const getProgressionBtn = document.getElementById("getProgressionBtn");
    const geminiOutputWrapper = document.getElementById("geminiOutputWrapper");
    const geminiOutput = document.getElementById("geminiOutput");

    function populateRootSelect() {
        allRootNotes.forEach(note => {
            const opt = document.createElement("option");
            opt.value = note;
            opt.textContent = note;
            rootSelect.appendChild(opt);
        });
    }

    function updateChoices() {
      choiceSelect.innerHTML = "";
      const selectedType = typeSelect.value;
      const obj = scaleTypes[selectedType];
      for (const name in obj) {
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        choiceSelect.appendChild(opt);
      }
      
      if (selectedType === 'mode') {
        choiceSelect.value = 'Ionian';
      }

      if (rootSelect.value) {
        showScaleBtn.click();
      }
    }
    
    // --- Initial Setup and Event Listeners ---
    populateRootSelect();
    typeSelect.value = 'mode';
    rootSelect.value = 'C';
    updateChoices();
    showScaleBtn.click();

    typeSelect.addEventListener("change", updateChoices);
    notationSelect.addEventListener("change", () => showScaleBtn.click());
    degreeToggle.addEventListener("change", () => showScaleBtn.click());
    rootSelect.addEventListener("change", () => showScaleBtn.click());
    choiceSelect.addEventListener("change", () => showScaleBtn.click());
    clearHighlightsBtn.addEventListener("click", clearVoicingHighlights); // ⭐ New Listener

    playScaleBtn.addEventListener("click", () => {
        const type = typeSelect.value;
        const choice = choiceSelect.value;
        const root = rootSelect.value;
        if (!root || !choice) return;
        
        // Ensure AudioContext is initialized/resumed on this user click
        initAudioContext(); 
        
        const intervals = scaleTypes[type]?.[choice];
        const { scaleNotes } = buildScale(root, intervals);
        
        playScale(scaleNotes);
    });

    showScaleBtn.addEventListener("click", () => {
      const type = typeSelect.value;
      const choice = choiceSelect.value;
      const root = rootSelect.value;

      if (!root || !choice) {
        document.getElementById("scaleNotes").innerHTML = `<span class="text-red-600 font-bold">⚠️ Please select a root note and a scale/mode choice.</span>`;
        document.getElementById("fretboard").innerHTML = "";
        chordOutputDiv.innerHTML = "";
        chordErrorP.classList.add('hidden');
        scaleAnalysisDiv.innerHTML = ""; 
        return;
      }

      const intervals = scaleTypes[type]?.[choice];
      const { scaleNotes } = buildScale(root, intervals);
      
      document.getElementById("scaleNotes").innerHTML =
        `**${root} ${choice}** Notes: <span class="font-bold text-indigo-900">${scaleNotes.join(" – ")}</span>`;
      
      renderScaleAnalysis(type, choice, root, intervals); 
      drawFretboard(scaleNotes, root, intervals, choice); 
      renderDiatonicChords(scaleNotes, root, choice); // Pass scale name for suggestions
    });
    
    // Scale Analysis Renderer
    function renderScaleAnalysis(type, choice, root, intervals) {
        const formula = intervals.join(" – ");
        const whTrail = calculateWHTrail(intervals);
        const derivation = getScaleDerivation(type, choice, root, intervals);
        
        scaleAnalysisDiv.innerHTML = `
            <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                <div class="p-2 bg-white rounded-md border border-indigo-100">
                    <span class="text-xs font-semibold uppercase text-gray-500 block">Formula (Interval Degrees)</span>
                    <span class="font-mono text-sm">${formula}</span>
                </div>
                <div class="p-2 bg-white rounded-md border border-indigo-100">
                    <span class="text-xs font-semibold uppercase text-gray-500 block">Whole/Half Steps (W/H)</span>
                    <span class="font-mono text-sm">${whTrail}</span>
                </div>
                <div class="p-2 bg-white rounded-md border border-indigo-100 md:col-span-1">
                    <span class="text-xs font-semibold uppercase text-gray-500 block">Derivation/Example</span>
                    <p class="text-sm">${derivation}</p>
                </div>
            </div>
        `;
    }

    // --- New Gemini API Integration ---

    /**
     * Shows a loading spinner and message in the Gemini output box.
     * @param {string} message - The message to display (e.g., "Generating...").
     */
    function showGeminiLoading(message) {
      geminiOutputWrapper.classList.remove('hidden');
      geminiOutput.innerHTML = `
        <div class="flex flex-col items-center justify-center">
          <div class="loader"></div>
          <p class="text-sm font-medium text-gray-600">${message}</p>
        </div>
      `;
    }

    /**
     * Shows an error message in the Gemini output box.
     * @param {string} message - The error message to display.
     */
    function showGeminiError(message) {
      geminiOutputWrapper.classList.remove('hidden');
      geminiOutput.innerHTML = `
        <div class="p-3 bg-red-100 text-red-700 rounded-lg">
          <p class="font-bold">Error</p>
          <p class="text-sm">${message}</p>
        </div>
      `;
    }

    /**
     * Displays the formatted text result from the Gemini API.
     * @param {string} text - The text content returned from the API.
     * @param {boolean} isTab - Whether to format the text as code (for guitar tabs).
     */
    function showGeminiResult(text, isTab = false) {
      geminiOutputWrapper.classList.remove('hidden');
      const formattedText = text.replace(/\n/g, '<br />');
      
      if (isTab) {
        // Use <pre> for tabs to preserve whitespace and font
        geminiOutput.innerHTML = `<div class="gemini-output"><pre>${text}</pre></div>`;
      } else {
        // Use standard paragraph for other text
        geminiOutput.innerHTML = `<p class="text-gray-700">${formattedText}</p>`;
      }
    }
    
    /**
     * A robust fetch wrapper that includes exponential backoff for retries.
     * This is crucial for handling API rate limits (429 errors).
     */
    async function fetchWithBackoff(url, options, retries = 4, delay = 1000) {
      try {
        const response = await fetch(url, options);
        if (!response.ok) {
          if ((response.status === 429 || response.status >= 500) && retries > 0) {
            // Do not log to console, just retry silently
            await new Promise(resolve => setTimeout(resolve, delay));
            return fetchWithBackoff(url, options, retries - 1, delay * 2);
          } else {
             const errorBody = await response.text();
             console.error("API Error Body:", errorBody);
             throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }
        }
        return response.json();
      } catch (error) {
        if (retries > 0) {
          // Network errors, etc.
          await new Promise(resolve => setTimeout(resolve, delay));
          return fetchWithBackoff(url, options, retries - 1, delay * 2);
        } else {
          console.error("Failed to fetch after multiple retries:", error);
          throw error;
        }
      }
    }

    /**
     * ⭐ SUGGESTION: SECURE Gemini API Call
     * This function is modified to call YOUR OWN serverless function (backend proxy)
     * instead of calling the Google API directly from the browser.
     * This protects your API key from being stolen.
     *
     * You would need to create a backend endpoint (e.g., at '/api/gemini')
     * that receives the { systemPrompt, userQuery } and then safely calls
     * the Google API from the server.
     */
    async function callGemini(systemPrompt, userQuery) {
      // const apiKey = ""; // 🛑 DANGER: Never put your API key in front-end JS!
      
      // ✅ GOOD: Call your own backend proxy endpoint
      const proxyApiUrl = '/api/gemini-proxy'; // Example: A Netlify/Vercel function

      const payload = {
        systemInstruction: systemPrompt,
        userQuery: userQuery
      };

      try {
         /*
         // This is the fetch call you would use for your *own* backend
        const response = await fetch(proxyApiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!response.ok) {
            throw new Error(`Proxy Error: ${response.status} ${response.statusText}`);
        }
        const result = await response.json();
        const text = result.text; // Assuming your proxy returns { text: "..." }
        */

        // --------------------------------------------------------------------
        // START: TEMPORARY MOCK (for testing without a backend)
        // This simulates a successful API call.
        // Replace this block with the real fetch call above when you
        // have a backend proxy set up.
        console.warn("Using MOCK Gemini response. Set up a backend proxy for real API calls.");
        await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate network delay
        let text = "";
        if (userQuery.includes("lick")) {
            text = `Here is a simple ${userQuery.match(/learning the (.*?) scale/)[1]} lick:\n\ne|------------------------|\nB|------------------------|\nG|----5-7-5---------------|\nD|--7-------7-5-----------|\nA|--------------7-6-5-----|\nE|--------------------8---|\n`;
        } else {
            text = "Here is a great practice progression:\n\n| Cmaj7 | Am7 | Dm7 | G7 |";
        }
        // END: TEMPORARY MOCK
        // --------------------------------------------------------------------


        if (text) {
          return text;
        } else {
          throw new Error("Invalid response structure from API proxy.");
        }
      } catch (error) {
        console.error("Error calling Gemini API proxy:", error);
        showGeminiError(`Failed to get response from AI. ${error.message}. (Note: This is a mock response. See code comments.)`);
        return null;
      }
    }


    /**
     * Event handler for the "Suggest a Lick" button.
     */
    async function handleGetLick() {
      const type = typeSelect.value;
      const choice = choiceSelect.value;
      const root = rootSelect.value;
      if (!root || !choice) {
        showGeminiError("Please select a scale and root note first.");
        return;
      }

      const intervals = scaleTypes[type]?.[choice];
      const { scaleNotes } = buildScale(root, intervals);

      const systemPrompt = "You are a helpful guitar instructor. Your goal is to provide a short, simple, and creative guitar lick for a student to practice. You MUST provide the lick in standard guitar tablature (tab) format, using plain text (e.g., e|--... B|--...). Do not use complex rhythms, just the notes. The lick should be 1-2 measures long and clearly demonstrate the sound of the scale.";
      const userQuery = `Please generate a simple guitar lick for me to practice. I am currently learning the ${root} ${choice} scale. Make sure the lick only uses notes from this scale (${scaleNotes.join(', ')}). Provide the response as simple text-based guitar tab.`;

      showGeminiLoading("Generating a practice lick...");
      
      const responseText = await callGemini(systemPrompt, userQuery);
      if (responseText) {
        showGeminiResult(responseText, true); // true = format as tab
      }
    }

    /**
     * Event handler for the "Suggest Chord Progression" button.
     */
    async function handleGetProgression() {
      const type = typeSelect.value;
      const choice = choiceSelect.value;
      const root = rootSelect.value;
      if (!root || !choice) {
        showGeminiError("Please select a scale and root note first.");
        return;
      }

      const systemPrompt = "You are a helpful music theory assistant. Your goal is to provide a simple, common 4-chord progression for a musician to practice improvising over. Use standard chord notation (e.g., Cmaj7, Gm7, A7). The progression should be idiomatic for the requested scale/mode.";
      const userQuery = `Generate a simple 4-chord progression for practicing over. I am in the key of ${root} ${choice}. The progression should be simple, repetitive, and good for practicing solos.`;

      showGeminiLoading("Generating a chord progression...");

      const responseText = await callGemini(systemPrompt, userQuery);
      if (responseText) {
        showGeminiResult(responseText, false); // false = format as standard text
      }
    }

    // --- Add New Event Listeners ---
    getLickBtn.addEventListener("click", handleGetLick);
    getProgressionBtn.addEventListener("click", handleGetProgression);


    // --- Chord Generation (FIXED) ---
    function getDiatonicChords(scaleNotes, root) {
      if (scaleNotes.length !== 7) return null; 

      const chords = [];

      for (let i = 0; i < scaleNotes.length; i++) {
        const chordRoot = scaleNotes[i];
        const notes = [
            scaleNotes[i], 
            scaleNotes[(i + 2) % 7], 
            scaleNotes[(i + 4) % 7], 
            scaleNotes[(i + 6) % 7]
        ];
        
        const r_idx = getNoteIndex(chordRoot);
        const intervalsInSemitones = notes.map(n => (getNoteIndex(n) - r_idx + 12) % 12);
        
        const thirdInterval = intervalsInSemitones[1];
        const fifthInterval = intervalsInSemitones[2];
        const seventhInterval = intervalsInSemitones[3];

        let quality = "7"; // Default

        const isMinor = thirdInterval === 3;
        const isMajor = thirdInterval === 4;
        const isDim5 = fifthInterval === 6;
        const isAug5 = fifthInterval === 8;
        const isPerf5 = fifthInterval === 7;
        const isMinor7 = seventhInterval === 10;
        const isMajor7 = seventhInterval === 11;

        if (isMajor && isPerf5 && isMajor7) quality = "Maj7";
        else if (isMajor && isPerf5 && isMinor7) quality = "7";
        else if (isMinor && isPerf5 && isMinor7) quality = "m7";
        else if (isMinor && isDim5 && isMinor7) quality = "m7b5";
        else if (isMajor && isAug5 && isMajor7) quality = "Maj7#5";
        else if (isMinor && isDim5 && isMajor7) quality = "m(Maj7)b5"; // Less common
        else if (isMinor && isPerf5 && isMajor7) quality = "m(Maj7)"; // Less common
        else if (isMajor && isDim5 && isMinor7) quality = "7b5"; // Less common

        // Find best matching voicing key
        const voicings = (voicingLibrary[quality] || voicingLibrary["m7"]).join(" | ");

        chords.push({
          degree: i + 1,
          root: chordRoot,
          quality: quality,
          notes: notes.join(", "),
          tension: '', // Removed broken tension logic
          voicings: voicings,
        });
      }
      return chords;
    }

    function toRoman(num) {
        const numerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X'];
        if (num > 0 && num <= numerals.length) {
            return numerals[num - 1];
        }
        return String(num); 
    }
    
    function getIntervalNameFromScale(note, root, intervals) {
        const rootIndex = getNoteIndex(root);
        const noteIndex = getNoteIndex(note);
        const semitoneOffset = (noteIndex - rootIndex + 12) % 12;
        
        for (let i = 0; i < intervals.length; i++) {
            if (intervalToSemitone(intervals[i]) === semitoneOffset) {
                return intervals[i] === '1' ? 'R' : intervals[i];
            }
        }
        return '';
    }

    /* ---------- FRETBOARD INTERACTION LOGIC (UPDATED) ---------- */

    function clearVoicingHighlights() {
        document.querySelectorAll('.voicing-highlight').forEach(el => el.remove());
    }

    // ⭐ UPDATED function: Now parses space-delimited strings and plays the chord
    function highlightVoicing(voicingString) {
        clearVoicingHighlights(); // Clear previous highlights

        // Get SVG element
        const svg = document.getElementById("fretboard").querySelector('svg');
        if (!svg || !voicingString) return;

        const frets = voicingString.split(' ');
        if (frets.length !== 6) {
            console.error("Invalid voicing string:", voicingString);
            return;
        }

        // Fretboard constants (must match drawFretboard)
        const strings = ["E","B","G","D","A","E"]; // High E (0) to Low E (5)
        const stringRoots = ["E", "A", "D", "G", "B", "E"]; // Low E (0) to High E (5) - for sound
        const numFrets = 15;
        const width = 1000;
        const height = 180;
        const margin = { left: 40, top: 20, right: 20, bottom: 20 };
        const drawingWidth = width - margin.left - margin.right;
        const fretSpacing = drawingWidth / (numFrets + 0.5);
        const stringSpacing = (height - margin.top - margin.bottom) / (strings.length - 1);

        const notesToPlay = [];

        // Voicing string is Low E (i=0) to High e (i=5)
        for (let i = 0; i < frets.length; i++) {
            const fretChar = frets[i];
            if (fretChar === 'x' || fretChar === 'X') continue;
            
            const f = parseInt(fretChar, 10);
            if (isNaN(f)) continue;

            // Calculate note for audio playback
            const rootIdx = getNoteIndex(stringRoots[i]);
            const noteIdx = (rootIdx + f) % 12;
            notesToPlay.push(getNoteName(noteIdx, 'sharp')); // Use 'sharp' for audio player

            // Calculate (x, y) for highlight circle
            let cx = f === 0 
                ? margin.left - fretSpacing / 2 
                : margin.left + f * fretSpacing - fretSpacing / 2;
                
            // Map string index (i=0 is Low E) to Y-coordinate (High E is 0, Low E is 5)
            const stringYIndex = (strings.length - 1) - i;
            const cy = margin.top + stringYIndex * stringSpacing;

            const r = 10;
            
            // Draw a distinct, temporary highlight circle
            const highlightCircle = createSVGElement("circle", {
                cx: cx, cy: cy, r: r,
                class: "voicing-highlight",
            });
            // Append the highlight *after* all other notes so it's on top
            svg.appendChild(highlightCircle);
        }
        
        // Play the chord!
        playChord(notesToPlay);
    }


    // --- Fretboard Drawing Logic (UPDATED) ---
    function drawFretboard(scaleNotes, root, intervals, choice) {
      clearVoicingHighlights(); // Clear any chord highlights when drawing a new scale
      
      // ⭐ NOTE: This array is [High E, B, G, D, A, Low E]
      // This matches the visual layout (i=0 is top string)
      const strings = ["E","B","G","D","A","E"]; 
      const notation = document.getElementById("notationSelect").value;
      const numFrets = 15;
      const width = 1000;
      const height = 180;
      const margin = { left: 40, top: 20, right: 20, bottom: 20 };
      const showDegrees = degreeToggle.checked;

      const fretboardDiv = document.getElementById("fretboard");
      fretboardDiv.innerHTML = "";

      const svg = createSVGElement("svg", {
          viewBox: `0 0 ${width} ${height}`,
          preserveAspectRatio: "xMinYMin meet",
          style: "width: 100%; min-width: 900px; height: auto;",
          role: "img", 
          'aria-label': `${root} ${choice} scale on guitar fretboard`
      });
      fretboardDiv.appendChild(svg);

      const drawingWidth = width - margin.left - margin.right;
      const fretSpacing = drawingWidth / (numFrets + 0.5);
      const stringSpacing = (height - margin.top - margin.bottom) / (strings.length - 1);
      const dotFrets = [3, 5, 7, 9, 12, 15];

      dotFrets.forEach(fret => {
        const cx = margin.left + fret * fretSpacing - fretSpacing / 2;
        const cy = height / 2;
        const attrs = { cx: cx, r: 5, class: "fret-dot" };

        if (fret === 12) {
          const offset = 25;
          svg.appendChild(createSVGElement("circle", { ...attrs, cy: cy - offset }));
          svg.appendChild(createSVGElement("circle", { ...attrs, cy: cy + offset }));
        } else {
          svg.appendChild(createSVGElement("circle", { ...attrs, cy: cy }));
        }
      });

      for (let f = 0; f <= numFrets; f++) {
        const x = margin.left + f * fretSpacing;
        svg.appendChild(createSVGElement("line", {
            x1: x, y1: margin.top, x2: x, y2: height - margin.bottom,
            class: f === 0 ? "nut" : "fret"
        }));
      }

      for (let i = 0; i < strings.length; i++) {
        const y = margin.top + i * stringSpacing;
        svg.appendChild(createSVGElement("line", {
            x1: margin.left, y1: y, x2: width - margin.right, y2: y,
            class: "string"
        }));
      }

      // Loop i=0 (High E) to i=5 (Low E)
      for (let i = 0; i < strings.length; i++) {
        const openNote = strings[i];
        const openIdx = getNoteIndex(openNote);

        for (let fret = 0; fret <= numFrets; fret++) {
          const noteIdx = (openIdx + fret) % 12;
          
          const noteDisplay = getNoteName(noteIdx, notation);

          if (scaleNotes.includes(noteDisplay)) {
            let cx = fret === 0 ? margin.left - fretSpacing / 2 : margin.left + fret * fretSpacing - fretSpacing / 2;
            const cy = margin.top + i * stringSpacing;
            const r = 12;

            const isRoot = getNoteIndex(noteDisplay) === getNoteIndex(root);
            
            const circle = createSVGElement("circle", {
                cx: cx, cy: cy, r: r,
                class: isRoot ? "root-circle" : "note-circle",
                'data-note': noteDisplay,
                'data-string': strings[i],
                'data-fret': fret
            });
            
            // ⭐ SUGGESTION: Add click-to-play for individual notes
            const octave = (i < 2) ? 2 : 1; // High E/B strings in C5, others in C4
            circle.addEventListener("click", () => {
                initAudioContext();
                playNote(noteDisplay, 0.5, 0, octave);
            });

            svg.appendChild(circle);
            
            const labelText = showDegrees 
                ? getIntervalNameFromScale(noteDisplay, root, intervals) 
                : noteDisplay;

            const text = createSVGElement("text", {
                x: cx, y: cy + 4,
                'text-anchor': "middle",
                'font-size': "10",
                'font-weight': "bold",
                class: "note-label"
            });
            text.textContent = labelText;
            svg.appendChild(text);
          }
        }
      }
    }

    /* ---------- NEW RENDER FUNCTION (handles non-7 scales with suggestions) ---------- */
    function renderDiatonicChords(scaleNotes, root, scaleName = "") {
      // Try to generate standard diatonic chords for 7-note scales
      const chords = (scaleNotes.length === 7) ? getDiatonicChords(scaleNotes, root) : null;

      chordOutputDiv.innerHTML = "";
      chordErrorP.classList.add('hidden');

      if (chords && chords.length > 0) {
        // Use existing table rendering (keep previous style)
        let html = `
          <div class="overflow-x-auto">
            <table class="min-w-full text-sm text-left text-gray-600 shadow-md rounded-lg overflow-hidden">
              <thead class="text-xs text-white uppercase bg-indigo-600">
                <tr>
                  <th class="px-3 py-3">Degree</th>
                  <th class="px-3 py-3">Chord Name</th>
                  <th class="px-3 py-3">Notes (R-3-5-7)</th>
                  <th class="px-3 py-3 hidden sm:table-cell">Quality</th>
                  <th class="px-3 py-3">Common Voicings (Click to Highlight & Play)</th>
                </tr>
              </thead>
              <tbody>
        `;
        chords.forEach((c, i) => {
          const rowColor = i % 2 === 0 ? 'bg-white' : 'bg-gray-50';
          
          const voicingList = c.voicings.split(' | ');
          const clickableVoicings = voicingList.map(v => 
            // ⭐ FIXED: Ensure onclick passes the trimmed, space-delimited string
            `<code onclick="highlightVoicing('${v.trim()}')" class="inline-block bg-gray-100 px-2 py-1 rounded mr-2 text-xs cursor-pointer hover:bg-indigo-200 transition duration-150">${v.trim()}</code>`
          ).join('');

          html += `
            <tr class="${rowColor} hover:bg-gray-100">
              <td class="px-3 py-2 font-bold text-gray-900">${toRoman(c.degree)}</td>
              <td class="px-3 py-2 text-indigo-700 font-extrabold">${c.root}${c.quality}</td>
              <td class="px-3 py-2 font-mono">${c.notes}</td>
              <td class="px-3 py-2 hidden sm:table-cell">${c.quality}</td>
              <td class="px-3 py-2 text-xs">${clickableVoicings}</td>
            </tr>
          `;
        });
        html += `</tbody></table></div>`;
        chordOutputDiv.innerHTML = html;
        return;
      }

      // Non-standard scales — show suggestions if available
      const suggestions = scaleChordSuggestions[scaleName] || [];

      if (suggestions.length === 0) {
        chordErrorP.textContent = "No pre-defined chord suggestions for this scale. This scale is highly non-standard for chord building.";
        chordErrorP.classList.remove('hidden');
        return;
      }

      // Build suggestions table
      let html = `
        <h3 class="text-lg font-semibold text-gray-700 mt-4 mb-3">Suggested Chords for ${scaleName}</h3>
        <div class="overflow-x-auto">
          <table class="min-w-full text-sm text-left text-gray-600 shadow-md rounded-lg overflow-hidden">
            <thead class="text-xs text-white uppercase bg-indigo-600">
              <tr>
                <th class="px-3 py-3">Suggested Chord</th>
                <th class="px-3 py-3">Idiomatic Use/Description</th>
                <th class="px-3 py-3">Common Voicings (Click to Highlight & Play)</th>
              </tr>
            </thead>
            <tbody>
      `;

      suggestions.forEach((s, idx) => {
        const rowColor = idx % 2 === 0 ? 'bg-white' : 'bg-gray-50';
        
        // Make voicings clickable
        const voicings = (s.voicings && s.voicings.length) 
            ? s.voicings.map(v => 
                // ⭐ FIXED: Ensure onclick passes the trimmed, space-delimited string
                `<code onclick="highlightVoicing('${v.trim()}')" class="inline-block bg-gray-100 px-2 py-1 rounded mr-2 text-xs cursor-pointer hover:bg-indigo-200 transition duration-150">${v.trim()}</code>`
            ).join('') 
            : '<em class="text-gray-400">none</em>';

        html += `
          <tr class="${rowColor} hover:bg-gray-100">
            <td class="px-3 py-2 font-extrabold text-indigo-700">${s.chord}</td>
            <td class="px-3 py-2">${s.label}</td>
            <td class="px-3 py-2">${voicings}</td>
          </tr>
        `;
      });

      html += `</tbody></table></div>`;
      chordOutputDiv.innerHTML = html;
    }
  </script>
</body>
</html>
